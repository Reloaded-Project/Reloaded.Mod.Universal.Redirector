{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"Reloaded-II Virtual File System \ud83c\udf88 Let's screw with binaries \ud83c\udf88 <p>A framework for creating virtual files at runtime.</p>"},{"location":"index.html#about-the-project","title":"About The Project","text":"<p>The Reloaded Virtual File System (VFS) is an invisible helper that sits between your games and the files they use. It allows your games to 'see' and  open files that aren't really 'there'; keeping your game folder unmodified.</p> <pre><code>flowchart LR\n\n    p[Game] -- Open File --&gt; vfs[Reloaded VFS]\n    vfs -- Open Different File --&gt; of[Operating System]</code></pre> <p>The VFS sits in the middle and does some magic \ud83d\ude07.</p> <pre><code>classDiagram    \n\n    class `Mod Folder`\n    `Mod Folder` : data3.pak\n\n    class `Mod 2 Folder`\n    `Mod 2 Folder` : data4.pak\n\n    class `Real Game Folder`\n    `Real Game Folder` : data1.pak\n    `Real Game Folder` : data2.pak\n    `Real Game Folder` : game.exe\n\n    class `Virtual Game Folder [What Game Sees]`\n    `Virtual Game Folder [What Game Sees]` : data1.pak\n    `Virtual Game Folder [What Game Sees]` : data2.pak\n    `Virtual Game Folder [What Game Sees]` : data3.pak\n    `Virtual Game Folder [What Game Sees]` : data4.pak\n    `Virtual Game Folder [What Game Sees]` : game.exe\n\n    `Mod Folder` --|&gt; `Virtual Game Folder [What Game Sees]`\n    `Mod 2 Folder` --|&gt; `Virtual Game Folder [What Game Sees]`\n    `Real Game Folder` --|&gt; `Virtual Game Folder [What Game Sees]`</code></pre>"},{"location":"index.html#usage-guide","title":"Usage Guide","text":"<p>You place files in a folder, and game can 'magically' see them. Please see Usage section for more details.</p>"},{"location":"index.html#performance-impact","title":"Performance Impact","text":"<p>The Reloaded VFS is optimized for file open operations, with a negligible performance  difference compared to not using VFS. In a test with opening+closing 21,000 files  (+70,000 virtualized), the difference was only ~41ms (~3%) or less than 2 microseconds per file.</p> <pre><code>// All tests done in separate processes for accuracy.\n|                           Method |    Mean |    Error |   StdDev | Ratio |\n|--------------------------------- |--------:|---------:|---------:|------:|\n|           OpenAllHandles_WithVfs | 1.650 s | 0.0102 s | 0.0095 s |  1.03 |\n| OpenAllHandles_WithVfs_Optimized | 1.643 s | 0.0145 s | 0.0135 s |  1.03 |\n|        OpenAllHandles_WithoutVfs | 1.602 s | 0.0128 s | 0.0120 s |  1.00 |\n</code></pre> <p>In real-world <code>\"cold-start\"</code> scenarios, this difference is effectively 0%. For more benchmarks, please see the Benchmarks page.</p>"},{"location":"index.html#how-to-contribute-wiki","title":"How to Contribute (Wiki)","text":"<ul> <li>Contributing to the Wiki: Online</li> <li>Contributing to the Wiki: Locally</li> </ul>"},{"location":"index.html#credits-attributions","title":"Credits, Attributions","text":"<ul> <li>Header icon created by Freepik - Flaticon</li> </ul>"},{"location":"about-the-vfs.html","title":"About the Reloaded Virtual FileSystem","text":"<p>Info</p> <p>Below are some characteristics of the virtual filesystem.</p> <p>Compared to Windows symlinks/hardlinks:  </p> <ul> <li>Links are only visible to the current application.  </li> <li>Write access to game folder is not needed. Can even link new content into read-only folders.  </li> <li>Administrator rights are not needed.  </li> <li>Can overlay multiple directories ontop of the destination.  </li> </ul> <p>And with the following benefits:  </p> <ul> <li>Easy to use API for programmers.  </li> <li>Practically zero overhead.  </li> <li>Can add/remove and remap files on the fly (without making changes on disk).  </li> </ul> <p>\ud83d\udc4d Also supports Wine on Linux.</p>"},{"location":"about-the-vfs.html#limitations","title":"Limitations","text":"<p>Info</p> <p>Write functionality in VFS scenarios can be ambiguous.</p> <p>For example, if you save a new file, where should it go?</p> <ul> <li>Original Folder?</li> <li>Some Mod's Folder?</li> <li>What if a folder is shared amongst multiple mods?</li> </ul> <p>To avoid these complications, Reloaded VFS only implements well defined functionality, effectively becoming a read-only VFS.</p> <p>Question</p> <p>But what does this mean?</p> <p>Well, quite simply. Any write operations, such as creating a file are unaffected.</p> <p>If a game wants to write a new file (such as a savefile), no action will be taken and the file will be written to the game folder. If a native DLL plugin wants to write a config file, it will write it to the game folder, as normal. That simple.</p>"},{"location":"about-the-vfs.html#warning","title":"Warning","text":"<p>Caution</p> <p>Proceed with care if any of the following applies:  </p> <ul> <li> <p>If your game's modding tools operate on a modified game directory (e.g. Skyrim xEdit),    using VFS is not recommended as new files might be written to the game folder.</p> </li> <li> <p>Do not use VFS to redirect files deleted and then recreated by games;    you will lose the files from inside your mod.</p> </li> </ul>"},{"location":"about-the-vfs.html#error-cases","title":"Error Cases","text":"<p>Failure</p> <p>Using this VFS is not appropriate for your game if any of the following is true.</p> <ul> <li>This VFS does not handle child processes.    Do not use VFS for games that can run external tools with virtualized files.</li> </ul>"},{"location":"about-the-vfs.html#information","title":"Information","text":"<p>Info</p> <p>The following limitations should not cause concern.</p> <ul> <li>Reloaded VFS does not support Reparse Point Tags.  <ul> <li>However, this shouldn't cause issues with mods stored on cloud/OneDrive/etc.  </li> </ul> </li> <li>Reloaded VFS does not return 8.3 DOS file names for virtualized files.  </li> </ul>"},{"location":"about-the-vfs.html#file-write-behaviours","title":"File Write Behaviours","text":"<p>Info</p> <p>Reloaded VFS is a read-only VFS, so what happens when you try editing files?</p> Description Action Performed File Deletion Delete the mod file instead of the original file New File Creation Create new files in the original game folder File Editing Edits the redirected file File Delete &amp; Recreate (New) Delete the overwritten file and place the new file in game folder Renaming Folders to Other Location Either move the original folder or files in original and overlaid folders (depends on how API is used)"},{"location":"benchmarks.html","title":"Performance Characteristics","text":"<p>Info</p> <p>All numbers were obtained on a stock clock 5900X and 3000MHZ CL16 RAM.</p> <p>The Reloaded VFS is heavily optimized for performance. A lot of micro-optimisations were done to squeeze every bit out of making opening files faster...</p> <ul> <li> <p>All strings stored as Wide Strings.  </p> <ul> <li>Windows APIs use Wide Strings under the hood, even for ANSI APIs.  </li> <li>Therefore we save time by not having to widen them again.  </li> </ul> </li> <li> <p>Custom string Hash Function for file paths.  </p> <ul> <li>With AVX and SSE implementations; aswell as unrolled <code>nint</code> as backup.  </li> </ul> </li> <li> <p>Custom Vectorized <code>ToUpper</code> for Strings.  </p> <ul> <li>Modified backport from .NET 8.  </li> <li>Super fast for 99% of the paths that are pure ASCII.  </li> <li>Non-ASCII paths use slower fallback since they can't be vectorized.  </li> <li>Partial ASCII paths have the first ASCII part vectorized and rest handled in fallback.  </li> </ul> </li> <li> <p>Custom Dictionary (HashMap) that can query string slices (to avoid copying/realloc).  </p> </li> <li> <p>Uses a custom 'LookupTree'.  </p> <ul> <li>Provides lookup for resolving file paths in O(3) time.  </li> </ul> </li> </ul>"},{"location":"benchmarks.html#file-mapping-performance-memory-usage","title":"File Mapping Performance &amp; Memory Usage","text":"<p>Info</p> <p>This section describes how long it takes to create a file map. A file map is a structure that helps redirect original files to their new versions found in mod folders.</p> <p>Whenever changes are made to mod folders, the file map needs to be rebuilt.</p> <p>Info</p> <p>Two types of maps exist, RedirectionTree and LookupTree.  The latter, <code>LookupTree</code> is optimised for performance, but takes roughly twice as long to build as it is built from the former <code>RedirectionTree</code>.</p> Folder Type Directories Total Items RedirectionTree (Time) RedirectionTree (Memory) LookupTree (Time) LookupTree (Memory) Windows Folder 40,796 170,438 43ms 27MB 32ms 25MB Steam Folder (65 games) 9,318 172,896 18ms 12MB 20ms 11MB <p>The performance of mapping operations mainly depends on the directory count. The table above shows the time and memory usage for building the <code>RedirectionTree</code> and <code>LookupTree</code> for both Windows and Steam folders. The <code>LookupTree</code> memory usage should be approximately equal to the total runtime memory usage.</p> <p>For a typical game (based on the median of a Steam library), building the <code>RedirectionTree</code> should take around <code>0.017ms</code> and allocate <code>48KB</code>. Creating the optimized <code>LookupTree</code> takes about <code>0.012ms</code> and allocates <code>47KB</code>.</p> <p>Success</p> <p>In other words, you can assume remapping files is basically real-time.</p>"},{"location":"benchmarks.html#fast-append","title":"Fast Append","text":"<p>Both <code>LookupTree</code> and <code>RedirectionTree</code> support <code>'fast append'</code> operations.  </p> <p>If a file is added to the mod folder while the game is running and isn't previously mapped,  it can be added to the tree directly without a full rebuild.</p> <p>However, if the currently mapped file's source mod cannot be determined, the entire tree  must be rebuilt. </p> <p>This process doesn't require scanning mod folders again for files when  not necessary. Each folder mapping has a cache of subdirectories and files, and the same  string instances are reused between the trees and cache to save memory.</p>"},{"location":"benchmarks.html#file-open-overhead","title":"File Open Overhead","text":"<p>File open has negligible performance difference compared to not using VFS. In a test with opening+closing 21,000 files (+70,000 virtualized), the difference  was only ~41ms (~3%) or less than 2 microseconds per file.</p> <pre><code>// All tests done in separate processes for accuracy.\n|                           Method |    Mean |    Error |   StdDev | Ratio |\n|--------------------------------- |--------:|---------:|---------:|------:|\n|           OpenAllHandles_WithVfs | 1.650 s | 0.0102 s | 0.0095 s |  1.03 |\n| OpenAllHandles_WithVfs_Optimized | 1.643 s | 0.0145 s | 0.0135 s |  1.03 |\n|        OpenAllHandles_WithoutVfs | 1.602 s | 0.0128 s | 0.0120 s |  1.00 |\n</code></pre> <p>In real-world <code>\"cold-start\"</code> scenarios (e.g. after a machine reboot), opening  these many files would take around 80 seconds, making this difference effectively  margin of error (~0%).</p>"},{"location":"benchmarks.html#built-in-benchmarks","title":"Built-in Benchmarks","text":"<p>Tip</p> <p>If you're a programmer, a lot of microbenchmarks are available in the <code>Reloaded.Universal.Redirector.Benchmarks</code> project; have a look!    </p>"},{"location":"programmer-usage.html","title":"Programmer Usage","text":"<p>Tip</p> <p>Redirector uses Reloaded Dependency Injection to expose an API. It's recommended to read that first if you haven't before already.</p> <p>Anyway, in short:  </p> <ul> <li>Add the <code>Reloaded.Universal.Redirector.Interfaces</code> NuGet package to your project.  </li> <li>Add the dependency <code>reloaded.universal.redirector</code> to <code>ModDependencies</code> in your <code>ModConfig.json</code>.  </li> <li>In your <code>Mod()</code> entry point, acquire the Controller <code>_modLoader.GetController&lt;IRedirectorController&gt;()</code>.</li> </ul>"},{"location":"usage.html","title":"Basic Usage","text":""},{"location":"usage.html#download-the-mod","title":"Download the Mod","text":"<p>First of all, download the mod which we will be using to extend the functionality of our mod. In this case, the <code>Reloaded File Redirector</code>.</p> <p></p>"},{"location":"usage.html#add-dependency-to-redirector","title":"Add Dependency to Redirector","text":"<p>In the <code>Edit Mod</code> menu we're going to add <code>Reloaded File Redirector</code> as a dependency.</p> <p></p> <p>Adding a 'dependency' to your mod will make it such that the other mod will always be loaded when your mod is loaded. This is a necessary step.</p>"},{"location":"usage.html#opening-the-mod-folder","title":"Opening the Mod Folder","text":"<p>Go to the folder where your mod is stored, this can be done by simply clicking the <code>Open Folder</code> button.</p>"},{"location":"usage.html#add-some-files","title":"Add Some Files","text":"<p>Make a folder called <code>Redirector</code>. Inside it place files that we want to be replaced.</p> <p></p> <p>Files are mapped by their location relative to the EXE of the application you are using the Redirector with.</p> <p>For a game at <code>E:/SonicHeroes/TSonic_win.exe</code>, the paths are relative to: <code>E:/SonicHeroes/</code>.</p> <p>To replace a music file at <code>E:/SonicHeroes/dvdroot/bgm/SNG_STG26.adx</code>, your mod should place the file at <code>Redirector/dvdroot/bgm/SNG_STG26.adx</code>.</p> <p>The contents of our mod folder should now look as follows.</p> <pre><code>// Mod Contents\nModConfig.json\nPreview.png\nRedirector\n\u2514\u2500dvdroot\n  \u251c\u2500advertise\n  \u2502   adv_pl_rouge.one\n  \u2514\u2500playmodel\n      ro.txd\n      ro_dff.one\n</code></pre> <p>The connectors <code>\u2514\u2500</code> represent folders.</p>"},{"location":"usage.html#debugging","title":"Debugging","text":"<p>To debug the mod, highlight the mod in the <code>Reloaded File Redirector</code> mod in your mod manager and click <code>Configure Mod</code>.  </p> <p>The following settings are available: - <code>Log Open Files</code>: Prints a message to <code>Console</code> when a new file is being opened. - <code>Log Redirections</code>: Prints a message when a custom file is loaded from your or another mod. - <code>Log Attribute Fetches</code>: Prints a message when game gets file properties such as file size.  </p>"},{"location":"guides/contributing-locally.html","title":"Contributing to the Index: Locally","text":""},{"location":"guides/contributing-locally.html#tutorial","title":"Tutorial","text":"<p>You should learn the basics of <code>git</code>, an easy way is to give GitHub Desktop (Tutorial) a go. It's only 15 minutes \ud83d\ude00.</p> <ol> <li>Create a GitHub account.</li> <li> <p>Fork this repository:</p> <p></p> <p>This will create a copy of the repository on your own user account, which you will be able to edit.</p> </li> <li> <p>Clone this repository.</p> <p>For example, using GitHub Desktop: </p> </li> <li> <p>Make changes inside the <code>docs</code> folder.</p> <p></p> <p>Consider using a Markdown Cheat Sheet if you are new to markdown.</p> <p>I recommend using a markdown editor such as <code>Typora</code>. Personally I use Visual Studio Code, which has built-in markdown support and preview available (<code>Ctrl+Shift+P</code> -&gt; <code>Markdown: Open Preview</code>). </p> </li> <li> <p>Commit the changes and push to GitHub.</p> </li> <li> <p>Open a <code>Pull Request</code>.</p> <p></p> <p>Opening a <code>Pull Request</code> will allow us to review your changes before adding them with the main official page. If everything's good, we'll hit the merge button and add your changes to the official repository.</p> </li> </ol>"},{"location":"guides/contributing-locally.html#website-live-preview","title":"Website Live Preview","text":"<p>If you are working on the Index locally, you can generate a live preview the full website. Here's a quick guide of how you could do it from your <code>command prompt</code> (cmd).</p> <ol> <li> <p>Install Python 3</p> <p>If you have <code>winget</code> installed, or Windows 11, you can do this from the command prompt. <pre><code>winget install Python.Python.3\n</code></pre></p> <p>Otherwise download Python 3 from the official website.</p> </li> <li> <p>Install Material for MkDocs (Python package)     <pre><code># Restart your command prompt before running this command.\npip install mkdocs-material\n</code></pre></p> </li> <li> <p>Open a command prompt in the Index folder and run the site locally.     <pre><code># Move to Index folder.\ncd &lt;Replace this with full path to your Index folder&gt;\nmkdocs serve\n</code></pre></p> <p></p> <p>Copy the address to your web browser and enjoy the live preview; any changes you save will be shown instantly.</p> </li> </ol>"},{"location":"guides/contributing-online.html","title":"Contributing to the Index: Online","text":"<p>(If you want to work purely in your web browser, recommended for small changes only)</p> <ol> <li>Create a GitHub Account.</li> <li> <p>Fork this repository:</p> <p></p> <p>This will create a copy of the repository on your own user account, which you will be able to edit.</p> </li> <li> <p>Open the <code>docs</code> folder and edit the relevant (.md) pages.</p> <p></p> <p>Consider using a Markdown Cheat Sheet for your editing needs.</p> </li> <li> <p>Open a <code>Pull Request</code>.</p> <p></p> <p>Opening a <code>Pull Request</code> will allow us to review your changes before adding them with the main official page. If everything's good, we'll hit the merge button and add your changes to the official repository.</p> </li> </ol>"},{"location":"implementationdetails/lookup-tree.html","title":"Lookup Tree","text":"<p>Tip</p> <p>This is a visualization of the data structure used to map paths of old files to new files after all mods are loaded during startup. When all mods are loaded, this structure is generated from the Redirection Tree.</p> <p>This is a data structure with O(3) lookup time that uses the following strategy: - Check common prefix. - Check remaining path in dictionary. - Check file name in dictionary.</p> <p>Use of prefix is based on the idea that a game will have all of its files stored under a common folder path. We use this to save memory in potentially huge games.  </p> <pre><code>flowchart LR\n\n    subgraph LookupTree\n    subgraph Common Prefix\n    G[C:/SteamLibrary/steamapps/common/Game]\n    end\n\n    subgraph Dictionary\n    D[.]\n    M[music]\n    end\n\n    G --&gt; D\n    D --&gt; data_1.pak\n    D --&gt; data_2.pak\n    D --&gt; data_3.pak\n    M --&gt; jingle.wav\n    M --&gt; ocean.wav\n    end\n\n    data_2.pak --&gt; f[FULL_PATH_TO_NEW_FILE 'isDirectory: false']</code></pre>"},{"location":"implementationdetails/lookup-tree.html#in-code","title":"In Code","text":"<pre><code>/// &lt;summary&gt;\n/// A version of &lt;see cref=\"RedirectionTree\"/&gt; optimised for faster lookups in the scenario of use with game folders.\n/// &lt;/summary&gt;\npublic struct LookupTree&lt;TTarget&gt;\n{\n/// &lt;summary&gt;\n/// Prefix of all paths.\n/// Stored in upper case for faster performance.\n/// &lt;/summary&gt;\npublic string Prefix { get; private set; }\n\n/// &lt;summary&gt;\n/// Dictionary that maps individual subfolders to map of files.\n/// &lt;/summary&gt;\npublic SpanOfCharDict&lt;SpanOfCharDict&lt;TTarget&gt;&gt; SubfolderToFiles { get; private set; }\n}\n</code></pre>"},{"location":"implementationdetails/redirection-tree.html","title":"Redirection Tree","text":"<p>Tip</p> <p>This is a visualization of the data structure used to map paths of old files to new files as the mods are loading during startup.</p> <p>This is a data structure with O(N) lookup time (where N is the number of components separated by '/') that make up the final file path. It uses the  following resolution steps:  </p> <ul> <li>Start at tree root.  </li> <li>Split the input path on '/' character.  </li> <li>Traverse the tree one level at a time, using each split component to move down next level.  </li> <li>At each level check if there's a child node corresponding to current path component.  <ul> <li>If there is no child node, lookup has failed and path is not in the tree.  </li> </ul> </li> <li>When all components have been consumed, check the <code>Items</code> dictionary of the final node reached to see if the path is present.  </li> <li>If it is, the lookup succeeds and the corresponding value is returned. If it is not, the lookup fails and the path is not found in the tree.  </li> </ul> <p>When all mods are loaded, this trie is converted to a Lookup Tree.</p> <pre><code>flowchart LR\n\n    subgraph RedirectionTree\n    C: --&gt; SteamLibrary --&gt; steamapps --&gt; common --&gt; Game\n    Game --&gt; data_1.pak\n    Game --&gt; data_2.pak\n    Game --&gt; data_3.pak\n    end\n\n    data_2.pak --&gt; f[FULL_PATH_TO_NEW_FILE 'isDirectory: false']</code></pre>"},{"location":"implementationdetails/redirection-tree.html#in-code","title":"In Code","text":"<pre><code>/// &lt;summary&gt;\n/// Represents that will be used for performing redirections.\n/// &lt;/summary&gt;\npublic struct RedirectionTree&lt;TTarget&gt;\n{\n/// &lt;summary&gt;\n/// Root nodes, e.g. would store drive: C:/D:/E: etc.\n/// In most cases there is only one.\n/// &lt;/summary&gt;\npublic RedirectionTreeNode&lt;TTarget&gt; RootNode { get; private set; }\n}\n</code></pre> <pre><code>/// &lt;summary&gt;\n/// Individual node in the redirection tree.\n/// &lt;/summary&gt;\npublic struct RedirectionTreeNode&lt;TTarget&gt;\n{\n/// &lt;summary&gt;\n/// Child nodes of this nodes.\n/// i.e. Maps 'folder' to next child.\n/// &lt;/summary&gt;\npublic SpanOfCharDict&lt;RedirectionTreeNode&lt;TTarget&gt;&gt; Children;\n\n/// &lt;summary&gt;\n/// Files present at this level of the tree.\n/// &lt;/summary&gt;\npublic SpanOfCharDict&lt;TTarget&gt; Items;\n}\n</code></pre> <pre><code>/// &lt;summary&gt;\n/// Target for a file covered by the redirection tree.\n/// &lt;/summary&gt;\npublic struct RedirectionTreeTarget\n{\n/// &lt;summary&gt;\n/// Path to the directory storing the file.\n/// &lt;/summary&gt;\npublic string Directory; // (This is deduplicated, saving memory)\n\n/// &lt;summary&gt;\n/// Name of the file in the directory.\n/// &lt;/summary&gt;\npublic string FileName;\n\n/// &lt;summary&gt;\n/// True if this is a directory, else false.\n/// &lt;/summary&gt;\npublic bool IsDirectory;\n}\n</code></pre>"},{"location":"implementationdetails/used-hooks.html","title":"Hook Flowchart","text":"<p>This page provides a flowchart showing how common Win32 and NT File APIs are handled by the hooks in this mod under the hood.</p> <p>The goal is to handle every API which:  </p> <ul> <li> <p>Accepts a File Path.  </p> <ul> <li>In this case we set a new path to our redirected file.  </li> </ul> </li> <li> <p>Returns Files at Given Path.  </p> <ul> <li>In this case we inject new files into the result.  </li> </ul> </li> </ul> <pre><code>flowchart LR\n    subgraph Win32\n\n    %% Definitions\n    FindFirstFileA\n    FindFirstFileExA\n    FindFirstFileW\n    FindFirstFileExW\n    FindFirstFileExFromAppW\n    FindNextFileA\n    FindNextFileW\n\n    CreateDirectoryA\n    CreateDirectoryW\n    CreateFileA\n    CreateFileW\n    CreateFile2\n    CreateFile2FromAppW\n    CreateFileFromAppW\n    CreateDirectoryExW\n    CreateDirectoryFromAppW\n    DeleteFileA\n    DeleteFileW\n    DeleteFileFromAppW\n    GetCompressedFileSizeA\n    GetCompressedFileSizeW\n    CloseHandle\n\n    GetFileAttributesA\n    GetFileAttributesExA\n    GetFileAttributesExFromAppW\n    GetFileAttributesExW\n    GetFileAttributesW\n    SetFileAttributesA\n    SetFileAttributesFromAppW\n    SetFileAttributesW\n\n    RemoveDirectoryA\n    RemoveDirectoryFromAppW\n    RemoveDirectoryW\n\n    %%% Win32 Internal Redirects\n    FindFirstFileA --&gt; FindFirstFileExW\n    FindFirstFileExA --&gt; FindFirstFileExW\n    FindFirstFileExFromAppW --&gt; FindFirstFileExW\n    FindNextFileA --&gt; FindNextFileW\n    CreateDirectoryA --&gt; CreateDirectoryW\n    CreateFile2FromAppW --&gt; CreateFile2\n    CreateDirectoryFromAppW --&gt; CreateDirectoryExW\n    CreateFileFromAppW --&gt; CreateFile2FromAppW\n    DeleteFileFromAppW --&gt; DeleteFileW\n    DeleteFileA --&gt; DeleteFileW\n    GetCompressedFileSizeA --&gt; GetCompressedFileSizeW\n    GetFileAttributesA --&gt; GetFileAttributesW\n    GetFileAttributesExA --&gt; GetFileAttributesExW\n    GetFileAttributesExFromAppW --&gt; GetFileAttributesExW\n    RemoveDirectoryA --&gt; RemoveDirectoryW\n    RemoveDirectoryFromAppW --&gt; RemoveDirectoryW\n    SetFileAttributesFromAppW --&gt; SetFileAttributesW\n    SetFileAttributesA --&gt; SetFileAttributesW\n    end\n\n    subgraph NT API\n    %% Definitions\n    NtCreateFile\n    NtOpenFile\n    NtQueryDirectoryFile\n    NtQueryDirectoryFileEx\n    NtDeleteFile\n    NtQueryAttributesFile\n    NtQueryFullAttributesFile\n    NtClose\n\n    %%% Win32 -&gt; NT API\n    FindFirstFileExW --&gt; NtOpenFile\n    FindFirstFileExW --&gt; NtQueryDirectoryFileEx\n    FindFirstFileW --&gt; NtOpenFile\n    FindFirstFileW --&gt; NtQueryDirectoryFileEx\n    FindNextFileW --&gt; NtQueryDirectoryFileEx\n    CreateFileA --&gt; NtCreateFile\n    CreateFileW --&gt; NtCreateFile\n    CreateFile2 --&gt; NtCreateFile\n    CreateDirectoryW --&gt; NtCreateFile\n    CreateDirectoryExW --&gt; NtOpenFile\n    CreateDirectoryExW --&gt; NtCreateFile\n    DeleteFileW --&gt; NtOpenFile\n    RemoveDirectoryW --&gt; NtOpenFile\n    GetCompressedFileSizeW --&gt; NtOpenFile\n    CloseHandle --&gt; NtClose\n    GetFileAttributesExW --&gt; NtQueryFullAttributesFile\n    GetFileAttributesW --&gt; NtQueryAttributesFile\n    SetFileAttributesW --&gt; NtOpenFile\n    end\n\n    %%% Hooks\n    subgraph Hooks\n    NtCreateFile_Hook\n    NtOpenFile_Hook\n    NtQueryDirectoryFileEx_Hook\n    NtDeleteFile_Hook\n    NtQueryAttributesFile_Hook\n    NtQueryFullAttributesFile_Hook\n    NtClose_Hook\n\n    %% NT API -&gt; Hooks\n    NtCreateFile --&gt; NtCreateFile_Hook\n    NtOpenFile --&gt; NtOpenFile_Hook\n    NtQueryDirectoryFileEx --&gt; NtQueryDirectoryFileEx_Hook\n    NtQueryDirectoryFile --&gt; NtQueryDirectoryFile_Hook\n\n    NtDeleteFile --&gt; NtDeleteFile_Hook\n    NtQueryAttributesFile --&gt; NtQueryAttributesFile_Hook\n    NtQueryFullAttributesFile --&gt; NtQueryFullAttributesFile_Hook\n    NtClose --&gt; NtClose_Hook\n    end</code></pre> <p>Confirmed by looking at Windows (7, 8.1, 10 &amp; 11) binaries and Wine 7.x source. Older Windows versions are no longer supported by me, MSFT or .NET runtime.</p>"},{"location":"implementationdetails/used-hooks.html#wine-windows-10-note","title":"Wine &amp; Windows &lt; 10 Note","text":"<p>On Windows versions greater 10 and greater, <code>NtQueryDirectoryFileEx</code> API becomes available and <code>NtQueryDirectoryFile</code> acts as a wrapper around it. On Wine and earlier Windows, only <code>NtQueryDirectoryFile</code> exists.</p> <p>In this VFS we hook both (just in case), and detect if one recurses to the other using a semaphore; if we're recursing from <code>NtQueryDirectoryFile</code> to <code>NtQueryDirectoryFileEx</code>, we skip our hook code.</p>"}]}